---
import "./_embed.css";
---

<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Habit Tracker</title>
  </head>
  <body>
    <div class="container">
      <div id="tracker"></div>
    </div>

    <script>
      const url = new URL(window.location.href);
      const trackerId = url.searchParams.get("tracker");

      const API_URL = `/api/habits/public/${trackerId}`;

      async function loadTracker() {
        const container = document.getElementById("tracker")!;

        try {
          const response = await fetch(API_URL);

          if (!response.ok) {
            const error = await response.json();
            if (error.code === "NOT_PUBLIC") {
              container.innerHTML =
                '<div class="error">This tracker is not public</div>';
            } else {
              container.innerHTML =
                '<div class="error">Tracker not found</div>';
            }
            return;
          }

          const data = await response.json();
          renderTracker(data);
        } catch (error) {
          console.error("Error loading tracker:", error);
          container.innerHTML =
            '<div class="error">Failed to load tracker</div>';
        }
      }

      // Convert hex to HSL
      function hexToHsl(hex) {
        const r = parseInt(hex.slice(1, 3), 16) / 255;
        const g = parseInt(hex.slice(3, 5), 16) / 255;
        const b = parseInt(hex.slice(5, 7), 16) / 255;

        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        let h = 0,
          s = 0,
          l = (max + min) / 2;

        if (max !== min) {
          const d = max - min;
          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
          switch (max) {
            case r:
              h = (g - b) / d + (g < b ? 6 : 0);
              break;
            case g:
              h = (b - r) / d + 2;
              break;
            case b:
              h = (r - g) / d + 4;
              break;
          }
          h /= 6;
        }

        return { h: h * 360, s: s * 100, l: l * 100 };
      }

      // Get color for count (matches React component)
      function getColorForCount(count, maxCount, color) {
        if (count === 0) return "transparent";

        const hsl = hexToHsl(color);
        const ratio = count / Math.max(maxCount, 1);
        const adjustedRatio = Math.pow(ratio, 0.9);

        const minLightness = Math.max(hsl.l - 25, 25);
        const maxLightness = Math.min(hsl.l + 65, 92);
        const minSaturation = Math.max(hsl.s - 65, 10);
        const maxSaturation = Math.min(hsl.s + 10, 100);

        const lightness =
          maxLightness - adjustedRatio * (maxLightness - minLightness);
        const saturation =
          minSaturation + adjustedRatio * (maxSaturation - minSaturation);

        return `hsl(${hsl.h}, ${saturation}%, ${lightness}%)`;
      }

      function renderTracker(data) {
        const { color, year, completions } = data;
        const baseColor = color || "#317e49";

        // Create a map of date -> count
        const completionMap = new Map();
        completions.forEach(({ date, count }) => {
          completionMap.set(date, count);
        });

        // Get max count for scaling
        const maxCount = Math.max(...completions.map((c) => c.count), 1);

        // Generate all days of the year
        const startDate = new Date(year, 0, 1);
        const endDate = new Date(year, 11, 31);
        const allDays = [];

        for (
          let date = new Date(startDate);
          date <= endDate;
          date.setDate(date.getDate() + 1)
        ) {
          allDays.push(new Date(date));
        }

        // Group days by week
        const weeks = [];
        let currentWeek = [];

        // Pad beginning to start on Sunday
        const firstDayOfWeek = allDays[0].getDay();
        for (let i = 0; i < firstDayOfWeek; i++) {
          currentWeek.push(null); // Empty day
        }

        allDays.forEach((day) => {
          currentWeek.push(day);
          if (currentWeek.length === 7) {
            weeks.push(currentWeek);
            currentWeek = [];
          }
        });

        // Add remaining days
        if (currentWeek.length > 0) {
          while (currentWeek.length < 7) {
            currentWeek.push(null); // Empty day
          }
          weeks.push(currentWeek);
        }

        // Create container
        const graphContainer = document.createElement("div");
        graphContainer.className = "graph-container";

        const graphWrapper = document.createElement("div");
        graphWrapper.className = "graph-wrapper";

        // Create month labels
        const monthLabels = document.createElement("div");
        monthLabels.className = "month-labels";

        weeks.forEach((_, i) => {
          const label = document.createElement("span");
          label.className = "month-label";

          if (i % 4 === 0) {
            const monthDate = new Date(year, Math.floor(i / 4), 1);
            label.textContent = monthDate.toLocaleString("default", {
              month: "short",
            });
          } else {
            label.className += " empty";
          }

          monthLabels.appendChild(label);
        });

        graphWrapper.appendChild(monthLabels);

        // Create weeks container
        const weeksContainer = document.createElement("div");
        weeksContainer.className = "weeks-container";

        weeks.forEach((week) => {
          const weekDiv = document.createElement("div");
          weekDiv.className = "week";

          week.forEach((day) => {
            const dayDiv = document.createElement("div");

            if (!day) {
              dayDiv.className = "day empty";
            } else {
              dayDiv.className = "day";

              const dateStr = day.toISOString().split("T")[0];
              const count = completionMap.get(dateStr) || 0;
              const dayColor = getColorForCount(count, maxCount, baseColor);

              if (count === 0) {
                dayDiv.style.background = "#eee";
              } else {
                dayDiv.style.background = dayColor;
              }

              const tooltip = `${day.toLocaleDateString()} - ${count} habit${
                count !== 1 ? "s" : ""
              }`;
              dayDiv.setAttribute("data-tooltip", tooltip);
            }

            weekDiv.appendChild(dayDiv);
          });

          weeksContainer.appendChild(weekDiv);
        });

        graphWrapper.appendChild(weeksContainer);

        // Create legend
        const legend = document.createElement("div");
        legend.className = "legend";

        const lessSpan = document.createElement("span");
        lessSpan.textContent = "Less";
        legend.appendChild(lessSpan);

        const legendBoxes = document.createElement("div");
        legendBoxes.className = "legend-boxes";

        for (let level = 0; level <= 4; level++) {
          const box = document.createElement("div");
          box.className = "legend-box";

          if (level === 0) {
            box.style.background = "#eee";
          } else {
            box.style.background = getColorForCount(level, 4, baseColor);
          }

          legendBoxes.appendChild(box);
        }

        legend.appendChild(legendBoxes);

        const moreSpan = document.createElement("span");
        moreSpan.textContent = "More";
        legend.appendChild(moreSpan);

        graphWrapper.appendChild(legend);
        graphContainer.appendChild(graphWrapper);

        const container = document.getElementById("tracker");
        container.innerHTML = "";
        container.appendChild(graphContainer);
      }

      // Load tracker on page load
      loadTracker();
    </script>
  </body>
</html>
